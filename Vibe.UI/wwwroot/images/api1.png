1/ Front

Démarrage et hébergement d'une application
******************************************
Pour expliquer les points communs entre tous les styles d'applications ASP.NET Core, j'utilise l'application avec laquelle vous démarrez lorsque vous démarrez une nouvelle application ASP.NET Core avec Visual Studio. 
Chaque application ASP.NET Core commence sa vie comme une console application normale. Lorsque l'application est démarrée, le code dans Program.cs est exécuté. 

Tout d'abord, un objet Builder est créé, qui est ensuite utilisé pour obtenir un objet App, qui est finalement commandé pour être lancé. 
Une fois lancé, la console application se transforme en une application ASP.NET Core. 

Cliquer sur le bouton Executer dans Visual Studioce qui lancera une session de débogage. Il est également possible d'ouvrir un terminal de cmd et de taper dotnet run. 

Le navigateur s'ouvre et affiche la page Web par défaut. Mais il y a aussi une autre application en cours d'exécution, qui ressemble à une application console. 
Il y a une certaine journalisation. Il semble écouter sur l'URL qui correspond à l'URL dans le navigateur. 
Cela signifie donc que notre application Web contient son propre serveur Web et que les navigateurs peuvent lui parler directement.Ce serveur Web intégré s'appelle Kestrel.

Ils peuvent simplement exécuter le projet. 
Cependant, lors de l'exécution d'une application en singerion, Kestrel ne suffit souvent
Dans ce cas, il est possible de mettre un serveur web devant votre application comme IIS lorsque vous êtes sous Windows. 
Ce serveur Web utilisera ensuite l'outil .NET CLI pour exécuter l'application et la maintenir en cours d'exécution. 
Les demandes entrantes vers IIS seront ensuite transmises à Kestrel, et les réponses passeront de Kestrel à IIS. 
Les développeurs peuvent imiter ce comportement au moment du développement en choisissant IIS Express dans cette liste déroulante, puis en exécutant l'application normalement. 

"... Kestrel isn’t a full-featured web server; rather, it’s a small, fast web server geared toward serving dynamic content from ASP.NET Core. 
The recommended way to use Kestrel in a production environment is to place it behind a reverse proxy. 
The reverse proxy can handle things that Kestrel isn’t well suited for—like serving static files, SSL termination, and response compression." 
-- Microservices in .NET Core
-- Christian Horsdal Gammelgaard

L'injection de dépendances est également vitale pour les applications ASP.NET Core. 
Nous verrons comment cela fonctionne, ensuite.

Injection de dépendance
**********************************
Je reviens au fichier Program.cs dans l'application. La partie juste au-dessus de la ligne qui crée l'objet app enregistre les services dans le conteneur d'injection de dépendance. 
L'injection de dépendances est une partie essentielle de chaque application ASP.NET Core. Le conteneur est un endroit central dans lequel les types peuvent être enregistrés. 
Chaque instance du type aura une durée de vie, qui est déterminée au moment de l'enregistrement. 
Une fois l'enregistrement effectué, nous pouvons demander une instance d'objet n'importe où dans l'application. 
L'objet sera automatiquement instancié lorsque nous le demanderons pour la première fois. 
Builder.Services est l'objet sur lequel effectuer l'enregistrement avant le réel l'application est lancée. 
AddRazorPages est ici une méthode d'extension qui enregistre tous les types nécessaires pour le moteur Razor Pages. 
Comme vous vous en souvenez peut-être, Razor Pages est l'un des styles d'application proposés par ASP.NET Core. 
Vous pouvez également enregistrer vos propres types dans un conteneur d'injection de dépendances. 
Vous apprendrez comment faire cela dans le prochain module où je vous montrerai la première application de démonstration. 
Je discute ensuite du reste de Program.cs.

Middleware et pipeline de requêtes
**********************************
Dans le fichier Program.cs, la partie entre la création de l' objet app et son exécution consiste en des appels de méthode sur l'objet app qui commencent principalement par le mot use. 
Nous configurons ici le pipeline de requêtes internes. C'est la partie où nous optons pour les fonctionnalités ASP.NET Core. 
Une fois qu'une demande atteint notre application via Kestrel, elle est traitée par un certain nombre d'étapes qui constituent le pipeline de demande. 
Ces étapes sont appelées middleware. Tous les intergiciels dans l'ordre auront la possibilité de faire quelque chose avec la requête, formant la réponse. 
Si vous ne configurez aucun middleware dans votre application, votre application ne fera tout simplement rien lorsqu'elle recevra une requête. 
Nous devons brancher un middleware pour le routage, qui mappe l'URL utilisée dans le navigateur à une partie de notre application. 
Et lorsque nous voulons rendre disponibles des fichiers statiques, tels que des images et des fichiers CSS et JavaScript, il existe un middleware pour cela. 
Il en va de même pour l'autorisation. Ainsi, dans le code, vous trouverez UseRouting, UseStaticFiles et UseAuthorization, qui sont toutes des méthodes d'extension qui configurent le middleware dans le pipeline. 
UseRouting, dans ce cas, active une fonctionnalité de routage générale, et MapRazorPages s'assurera que l'URL est mappée à une page Razor correspondante. 
Cette dernière partie est spécifique au style d'application, RazorPages. 
L'ordre dans lequel le middleware est branché est important puisque le les données de la demande parcourent le middleware dans l'ordre. Avant d'afficher une page Razor, vous souhaitez par exemple effectuer une autorisation. 
Il y a autre chose à dire sur le middleware StaticFiles. Seuls les fichiers présents dans le dossier wwwroot sont accessibles par ce middleware, donc tous les fichiers statiques doivent s'y trouver. 
Tous les autres fichiers du projet ne peuvent pas être téléchargés directement. 
Il existe de nombreux autres exemples de construction d'intergiciels, et il est également possible de créer le vôtre. 
Vous verrez ensuite comment écrire la partie interface utilisateur d'une application ASP.NET Core.

Pages Razor : pages, routage et assistants de balises
********************************************************************
Avec Razor Pages, le mécanisme de routage d'ASP.NET Core prend l'URL qu'il reçoit et la mappe à quelque chose appelé Razor Page, qui est sans surprise une page écrite à l'aide de la syntaxe Razor.
Dans cet exemple, le /index après sculptérock.com est interprété comme une requête pour une page nommée index.
Le serveur fera tout ce qui est nécessaire pour afficher la page et fournir le code HTML au navigateur.
Il y a quelque chose de spécial à propos d'une page appelée index.
C'est une page par défaut.
Ainsi, lorsque seule l'URL nue est utilisée, Razor Pages affichera la page d'index.
Laisse moi te montrer.
Pas de /index derrière l'URL, mais la page d'index s'affiche.
L'ajout d'un index à l'URL affiche la même page.
Nous examinons l'emplacement de la page d'index dans le projet.
Il se trouve dans un dossier appelé Pages et porte l'extension cshtml.
Jetez un œil à cette syntaxe Razor.
C'est juste une partie d'une page HTML complète.
Il nous manque les balises HTML externes, ainsi que le logo sculpté, par exemple.
C'est parce que cette page utilise une page de mise en page.
Sous le dossier partagé, il y a un fichier _Layout.cshtml, qui contient la structure HTML environnante.
Notre page d'index est rendue à l'endroit où il est écrit @RenderBody().
Par défaut, toutes les pages utiliseront cette même page de mise en page, ce qui nous évite de saisir le même balisage encore et encore.
Retour à la page Index Razor.
La première ligne en fait une page Razor, et il y a un modèle déclaré.
L'objet est référencé dans Razor en tant que modèle.
Il est utilisé pour rendre le singer avec C # pour chaque instruction, en itérant sur une propriété de l'objet appelé singer.
Maintenant, d'où vient le modèle ? Lorsque je clique sur le petit triangle devant Index.cshtml, Index.cshtml.cs apparaît, qui contient la classe IndexModel dérivant de la classe de base PageModel fournie par le framework Razor Pages.
IndexModel a une propriété singers que nous avons vue référencée tout à l'heure dans Index.cshtml, et il existe une méthode, OnGet(), qui la remplit avec tous les singers en appelant une méthode sur singerRepository, qui est injectée par le conteneur d'injection de dépendance.
OnGet() est appelé une méthode de gestionnaire.
Il sera exécuté lorsque la page recevra une requête get.
Il y a une autre chose intéressante dans le Razor que je veux vous montrer.
Il existe une balise d'ancrage dotée d'un attribut appelé asp‑page.
Ce n'est pas un attribut HTML standard.
Ceci est un exemple d'assistant de balise.
Cet attribut est traité par ASP.NET Core lorsqu'il restitue la page comme le C# intégré.
Asp‑page prend le nom d'une page et le transforme en une URL, qui est ensuite rendue dans l' attribut href de la balise d'ancrage.
Cela générera donc un lien vers la page Créer.

Pages Razor : publication de données, validation et liaison de données
**********************************************************************
Jetons un coup d'œil à la page Créer maintenant.
Il contient un formulaire HTML qui génère une demande de publication.
Il n'y a rien de spécial dans le formulaire lui-même, à l'exception du fait que des assistants de balises sont utilisés.
Asp‑validation‑summary affiche une liste de toutes les erreurs de validation dès qu'elles sont présentes, et asp‑for, présent à la fois sur les étiquettes et les entrées, référence une propriété dans le modèle appelée Newsinger.
Voici le modèle avec une propriété Newsinger.
Il est décoré avec un attribut BindProperty.
Cela signifie que dès que le formulaire est posté, cet objet sera automatiquement rempli avec les valeurs postées.
C'est ce qu'on appelle la liaison de données, et voici comment cela fonctionne.
Les éléments d'entrée avec les assistants de balise asp-for dans le Razor que je vous ai montré ressembleront à ceci lorsque le code HTML sera envoyé au navigateur.
Le nom de l'entrée est Newsinger.Name et Newsinger.Price et les deux entrées ont une valeur.
Lorsque le formulaire est publié, ASP.NET Core essaie désormais de lier les valeurs à un objet avec un attribut BindProperty dont le nom est spécifié dans le nom de l'entrée avant le point.
Dans ce cas, nous avons une correspondance, et après cela, il recherchera une propriété sur l'objet qui est spécifiée après le point.
Étant donné que la classe singer a une propriété Name et Price, les valeurs de propriété dans l'objet obtiendront automatiquement leurs valeurs à partir des données publiées.
Revenant à la classe Model, elle a également une méthode de gestionnaire, mais cette fois, la méthode sera déclenchée lorsqu'une demande de publication est reçue lors de la publication du formulaire.
Dans celui-ci, nous disons simplement au singerRepository d'ajouter un nouveau singer.
Rien de plus n'est nécessaire car Newsinger sera désormais rempli automatiquement avec les données publiées, mais il y a plus dans OnPost.
ModelState IsValid vérifiera s'il y a des erreurs de validation.
Les attributs d'annotation de données que je vous ai montrés plus tôt seront utilisés pour valider les données entrantes.
Lorsqu'il y a une erreur de validation, c'est-à-dire que le ModelState n'est pas valide, nous renvoyons un objet qui provient d'un appel à la méthode Page.
Il s'agit d'un objet qui implémente l'interface IActionResult, type de retour OnPost.
Cet objet s'assurera que la page actuelle, dans ce cas, la page Créer, est réaffichée, mais puisqu'il y a maintenant des erreurs de validation, le résumé de validation s'affichera.
Laisse moi te montrer.
Laissons la valeur du nom vide car l'attribut requis est présent sur la propriété Name du singer, le ModelState ne sera pas valide.
La même page s'affiche, mais maintenant l'erreur de validation s'affiche.
Lorsqu'il n'y a pas d'erreurs de validation, après l'ajout du singer au référentiel, un objet RedirectToPage est renvoyé qui implémente également IActionResult.
Cela redirigera vers la page spécifiée, dans ce cas, l'index, qui affichera à nouveau la liste des singers.

NB: MVC utilise les mêmes principes que Razor Pages, mais il existe des différences, et nous les étudierons ensuite.
Les deux sont des  applications frontales rendues par le serveur
Il existe également applications frontales rendues par le client Blazor WebAssembly et Serveur Blazor 


2/ API backend
****************************************************************
Applications API
**********************************
ASP.NET Core est idéal pour les applications backend.
Encore une fois, nous avons des options, l'API Web et gRPC utilisent deux modèles différents, et SignalR peut également être considéré comme une API qui prend en charge la communication serveur à client .
 
Une API doit pouvoir envoyer et recevoir des données. Nous utilisons la sérialisation pour cela en transformant des objets C# dans un format (exemple du JSON) qui peut être envoyé à travers le réseau.
L'extrémité réceptrice peut alors restituer les données sérialisées sous forme d'objets à nouveau en utilisant la désérialisation.

Voici la nouvelle architecture de l'application qui inclut les API.
api1.png
capture1/capture2

Le navigateur interagira avec le serveur pour obtenir les pages, comme nous l'avons vu.
Lorsque des données sont nécessaires, l'application serveur contactera l'API pour obtenir les données.
Lorsque de nouvelles données sont introduites ou modifiées, elles contactent à nouveau l'API pour les faire persister et vérifier.
 

REST
**********************************
L'API Web dans ASP.NET Core nous permet d'écrire des API basées sur REST, également appelées API RESTful.
Généralement, dans une API REST, le protocole HTTP est exploité. Nous utilisons des requêtes et des réponses HTTP, et chaque élément de données est disponible sur un point de terminaison unique appeléEnd point.

Une liste de chanteurs, par exemple, pourrait être disponible sur /singers et un singer avec un ID de 1 sur /singer/1.
Nous utilisons les méthodes HTTP, telles que GET, POST et PUT, pour déterminer ce que nous voulons faire.
Un GET est utilisé pour récupérer des données et un POST pour introduire des nouvelles données. Avec un PUT, nous mettons à jour les données.

Lorsqu'une réponse revient, nous pouvons examiner le code d'état de la requête HTTP pour voir comment cela s'est passé.
Par exemple un code d'état HTTP 200 lors d'un get indiquera que tout s'est bien passé, et les données sont contenues dans la réponse.
Un code d'état 404 indiquerait qu'il n'a pas pu trouver les données demandées.


return CreatedAtAction(nameof(GetOne), new { id = singer.Id }, singer);

Les réponses peuvent également contenir des pointeurs sous la forme d'URL avec des suggestions sur ce qu'il faut faire ensuite. 
Lorsqu'un nouveau singer est introduit avec un POST, la réponse peut contenir l'URL sur laquelle trouver le nouveau singer. 

L'API Web peut prendre en charge d'autres formats, mais dans la grande majorité des cas, JSON sera utilisé comme format de sérialisation.
C'est aussi la valeur par défaut.


Web API
**********************************
Voici l'exemple de projet pour l'API Web.
Notez que nous avons trois projets dans la solution, une application frontale Razor pages, le projet Web API et une bibliothèque de classes qui partage la classe de singer entre les différentes couches.
 
Dans Program.cs, nous ajoutons simplement la prise en charge du contrôleur au conteneur d'injection de dépendances. Et à la fin, on mappe les contrôleurs, mais cette fois sans table de routage.

Alors, comment l'API Web sait-elle comment mapper les URL aux actions du contrôleur ?  

Je tiens à souligner deux autres choses dans Program.cs.
Tout d'abord, la prise en charge de Swagger est ajoutée. Swagger est un autre mot pour OpenAPI, une norme qui décrit une API REST.
app.UseSwagger();
Nous ajoutons également la prise en charge d'une interface utilisateur autour de cela. Avec une interface utilisateur en place, nous pouvons ouvrir un navigateur et accéder à l'URL /swagger.
Swagger sert de documentation pour cette API. Nous pouvons voir quels points de terminaison cette API est disponible.
app.UseSwaggerUI();

En revenant à Program.cs, la prise en charge de CORS est également ajoutée. app.UseCors(...);
Les requêtes effectuées par des applications qui s'exécutent dans le navigateur en dehors du domaine utilisé par l'application frontale ne sont pas possibles, sauf autorisation explicite.
Avec CORS, je peux autoriser explicitement notre application Razor page.

Voici le cœur de l'API, le contrôleur.
C'est une classe qui dérive de ControllerBase, qui est essentiellement un contrôleur sans prise en charge de la vue.
Il est décoré par l'attribut ApiController. Cet attribut active les fonctionnalités de l'API sur le contrôleur.
L'une des choses qu'il fait est d'exiger un routage d'attribut au lieu d'une table de routage.

Nous spécifions maintenant la route de base pour le contrôleur comme ceci.
Contrôleur ici est une expression qui évaluera le nom du contrôleur sans le suffixe du contrôleur. Donc, dans ce cas, singer.

Le contrôleur a une action appelée GetAll, qui renvoie un ActionResult.Cette fois, nous utilisons ActionResults qui transmet un code d'état HTTP en réponse afin que les appelants puissent voir le résultat de leur demande.
Lorsqu'il n'y a pas de singers, nous renvoyons NoContent.C'est le code d'état HTTP 204, par exemple. Et lorsque tout a été réussi, nous retournons le code de statut Ok 200 avec la liste des singers.
Quant à la sérialisation de l'objet singer, elle est automatique.

L'action GetAll est configurée pour répondre à une requête GET.
Cela signifie donc que lorsqu'une requête GET est envoyée à /singer, cette action s'exécutera.

GetOne répond également à une requête GET, mais il dispose d'informations de routage supplémentaires.
Il est configuré pour attendre un ID dans l'URL qui doit être un nombre entier.
S'il y a une correspondance avec cette route, l'action se déclenchera, et le paramètre id obtiendra automatiquement sa valeur à partir de l'URL.
Nous obtenons le singer du référentiel à l'aide de l'ID. S'il n'y a pas de singer de ce type, nous renvoyons le code d'état HTTP 404 NotFound. S'il y en a, nous retournons à nouveau Ok avec le singer.

Il y a une autre action dans le contrôleur qui prend un singer comme paramètre et réagit à un POST.
Encore une fois, la liaison de données, prendre les données de la requête et les désérialiser dans un singer, est automatique.
Nous pouvons également effectuer une validation à l'aide de ModelState, renvoyant un code d'état HTTP 400, BadRequest, lorsque le singer ne passe pas la validation.
Mais parce que nous avons décoré le contrôleur avec ApiAttribute, ce code n'est en fait pas nécessaire car il est fait automatiquement par l'API Web.
Ainsi, la seule chose que nous avons à faire est d'ajouter le singer au référentiel et de renvoyer un code de statut 201 Créé.
Avec le résultat de l'action CreatedAtAction, nous pouvons inclure l'URL du singer nouvellement créé dans la réponse.
Bon, maintenant que nous avons une API entièrement fonctionnelle, il est temps de la consommer à partir de l'application Razor page.

Consommer une API Web
**********************************
J'ai un peu modifié le Program.cs de l'application Razor page.
Un HttpClient est ajouté au conteneur d'injection de dépendance.
HttpClient est la classe à utiliser pour faire des requêtes HTTP.
Il est configuré pour envoyer les requêtes à l'API.
Maintenant que la classe de référentiel est déplacée vers l'API, j'ai introduit une classe singerApiService qui est chargée de faire les demandes réelles.
Nous allons jeter un coup d'oeil.
Il obtient le HttpClient injecté.
Dans GetAll, il l'utilise pour faire une requête GET à l'URL du singer.
Et la ligne suivante garantit un code d'état HTTP dans la plage 200, ce qui indique le succès.
Si un autre code d'état est renvoyé, une exception est levée ici.
Après ça, les données contenues dans la réponse sont lues et désérialisées dans un IEnumerable de Singer, qui est renvoyé par la méthode.

La méthode Add obtient un singer en tant que paramètre qui est encapsulé dans un objet jsonContent.
Cet objet peut ensuite être utilisé pour faire une requête POST à ​​l'URL du singer.
La charge utile de la requête sera le singer sérialisé en JSON.
Souvent, des éléments tels que l'ID du singer sont ajoutés par l'API.
Il est important que l'appelant obtienne cette information.
C'est pourquoi la réponse contiendra le singer tel qu'il a été ajouté au magasin de données, que nous pouvons désérialiser et renvoyer.
Le code de notre page Indexer et créer n'a pas changé du tout, à l'exception de la fait que nous obtenons maintenant le singerApiService injecté au lieu du singerRepository, en appelant les méthodes pertinentes à ce sujet.

À côté du modèle de contrôleur, il existe une autre façon de créer une API Web.
Vous verrez cela ensuite.